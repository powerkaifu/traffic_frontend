# 問題排除

## 🚨 常見問題分類

### 🎨 動畫與視覺問題

### 🔗 API 通訊問題

### 🧠 邏輯與狀態問題

### ⚡ 效能問題

### 🔧 配置與環境問題

---

## 🎨 動畫與視覺問題

### 問題 1：車輛動畫卡頓或不流暢

**症狀**：

- 車輛移動時出現跳躍或停頓
- 動畫播放速度不一致
- 瀏覽器 FPS 過低

**可能原因**：

1. 同時執行的動畫數量過多
2. DOM 元素更新頻率過高
3. 記憶體洩漏導致效能下降
4. GSAP 時間軸衝突

**解決方案**：

```javascript
// 1. 檢查動畫數量
console.log('活躍動畫數量:', gsap.getTweensOf('*').length)

// 2. 實現動畫池管理
class AnimationPool {
  constructor(maxAnimations = 20) {
    this.maxAnimations = maxAnimations
    this.activeAnimations = new Set()
  }

  addAnimation(tween) {
    if (this.activeAnimations.size >= this.maxAnimations) {
      this.killOldestAnimation()
    }
    this.activeAnimations.add(tween)

    tween.eventCallback('onComplete', () => {
      this.activeAnimations.delete(tween)
    })
  }
}

// 3. 檢查記憶體使用
const checkMemoryUsage = () => {
  if (performance.memory) {
    console.log('記憶體使用:', {
      used: Math.round(performance.memory.usedJSHeapSize / 1048576) + 'MB',
      total: Math.round(performance.memory.totalJSHeapSize / 1048576) + 'MB',
    })
  }
}

// 4. 清理無效的時間軸
const cleanupTimelines = () => {
  const vehicles = document.querySelectorAll('.vehicle')
  vehicles.forEach((vehicle) => {
    if (!vehicle.offsetParent) {
      // 元素已被移除
      gsap.killTweensOf(vehicle)
    }
  })
}
```

**除錯步驟**：

1. 開啟瀏覽器開發者工具 → Performance 頁籤
2. 開始錄製效能，執行動畫一段時間
3. 檢查 FPS 圖表和主執行緒活動
4. 查看是否有長時間執行的任務

### 問題 2：車輛轉彎路徑不正確

**症狀**：

- 車輛轉彎時路徑異常
- 車輛重疊或碰撞
- 轉彎半徑不符合預期

**可能原因**：

1. 轉彎座標計算錯誤
2. 路徑點設定不當
3. 動畫時序問題

**解決方案**：

```javascript
// 1. 檢查轉彎座標
const debugTurnPath = (vehicle) => {
  const path = vehicle.calculateTurnPath()
  console.log('轉彎路徑:', path)

  // 視覺化路徑點
  path.forEach((point, index) => {
    const marker = document.createElement('div')
    marker.style.cssText = `
            position: absolute;
            left: ${point.x}px;
            top: ${point.y}px;
            width: 5px;
            height: 5px;
            background: red;
            z-index: 1000;
        `
    marker.textContent = index
    document.body.appendChild(marker)

    setTimeout(() => marker.remove(), 5000)
  })
}

// 2. 修正轉彎計算
const fixTurnCalculation = () => {
  // 確保轉彎半徑合理
  const minTurnRadius = 50
  const maxTurnRadius = 100

  // 根據車輛類型調整轉彎半徑
  const getTurnRadius = (vehicleType) => {
    switch (vehicleType) {
      case 'large':
        return maxTurnRadius
      case 'small':
        return minTurnRadius
      case 'motor':
        return minTurnRadius * 0.8
      default:
        return (minTurnRadius + maxTurnRadius) / 2
    }
  }
}
```

### 問題 3：燈號顯示異常

**症狀**：

- 燈號顏色不正確
- 燈號切換不同步
- 燈號圖片無法載入

**解決方案**：

```javascript
// 1. 檢查燈號狀態同步
const debugLightStates = () => {
  const controller = window.trafficController
  console.log('燈號狀態:', controller.getCurrentLightStates())

  // 檢查每個燈號的實際 DOM 狀態
  Object.keys(controller.trafficLights).forEach((direction) => {
    const light = controller.trafficLights[direction]
    console.log(`${direction} 燈號:`, {
      state: light.currentState,
      element: light.element?.className,
      visible: light.element?.offsetParent !== null,
    })
  })
}

// 2. 強制重新整理燈號顯示
const refreshTrafficLights = () => {
  const controller = window.trafficController
  Object.values(controller.trafficLights).forEach((light) => {
    light.updateVisualState()
  })
}

// 3. 檢查圖片資源
const checkImageResources = () => {
  const images = ['redLight.png', 'yellowLight.png', 'greenLight.png']
  images.forEach((img) => {
    const testImg = new Image()
    testImg.onload = () => console.log(`✓ ${img} 載入成功`)
    testImg.onerror = () => console.error(`✗ ${img} 載入失敗`)
    testImg.src = `/images/light/${img}`
  })
}
```

---

## 🔗 API 通訊問題

### 問題 4：API 請求失敗或超時

**症狀**：

- 無法連接到後端 AI 服務
- 請求回應時間過長
- 收到 CORS 錯誤

**除錯步驟**：

```javascript
// 1. 檢查 API 連線狀態
const testAPIConnection = async () => {
  try {
    const response = await fetch('/api/health', {
      method: 'GET',
      timeout: 5000,
    })

    if (response.ok) {
      console.log('✓ API 連線正常')
    } else {
      console.error('✗ API 回應錯誤:', response.status)
    }
  } catch (error) {
    console.error('✗ API 連線失敗:', error.message)

    // 檢查是否為 CORS 問題
    if (error.message.includes('CORS')) {
      console.log('CORS 問題解決建議:')
      console.log('1. 檢查後端 CORS 設定')
      console.log('2. 確認 API 網址正確')
      console.log('3. 檢查請求標頭設定')
    }
  }
}

// 2. 監控 API 效能
class APIMonitor {
  constructor() {
    this.requestTimes = []
    this.errorCount = 0
  }

  recordRequest(startTime, success) {
    const responseTime = Date.now() - startTime
    this.requestTimes.push(responseTime)

    if (!success) this.errorCount++

    // 保持最近 100 次記錄
    if (this.requestTimes.length > 100) {
      this.requestTimes.shift()
    }

    this.reportStats()
  }

  reportStats() {
    const avg = this.requestTimes.reduce((a, b) => a + b, 0) / this.requestTimes.length
    const max = Math.max(...this.requestTimes)
    const errorRate = this.errorCount / this.requestTimes.length

    console.log('API 效能統計:', {
      平均回應時間: Math.round(avg) + 'ms',
      最大回應時間: max + 'ms',
      錯誤率: Math.round(errorRate * 100) + '%',
    })
  }
}
```

### 問題 5：數據格式不匹配

**症狀**：

- 後端回傳格式錯誤
- 數據驗證失敗
- AI 建議無法解析

**解決方案**：

```javascript
// 1. 數據格式驗證器
const validateAPIData = (data) => {
  const schema = {
    timestamp: 'number',
    vehicles: 'object',
    currentLights: 'object',
    scene: 'string',
  }

  const errors = []

  Object.keys(schema).forEach((key) => {
    if (!(key in data)) {
      errors.push(`缺少必要欄位: ${key}`)
    } else if (typeof data[key] !== schema[key]) {
      errors.push(`欄位 ${key} 類型錯誤: 期望 ${schema[key]}, 得到 ${typeof data[key]}`)
    }
  })

  if (errors.length > 0) {
    console.error('數據驗證失敗:', errors)
    return false
  }

  return true
}

// 2. 數據格式轉換器
const convertLegacyFormat = (oldData) => {
  // 轉換舊格式到新格式
  if (oldData.vehicles && !oldData.vehicles.north) {
    // 舊格式轉換
    const newFormat = {
      timestamp: oldData.time || Date.now(),
      vehicles: {
        north: oldData.northVehicles || { motor: 0, small: 0, large: 0 },
        south: oldData.southVehicles || { motor: 0, small: 0, large: 0 },
        east: oldData.eastVehicles || { motor: 0, small: 0, large: 0 },
        west: oldData.westVehicles || { motor: 0, small: 0, large: 0 },
      },
      currentLights: oldData.lights || {},
      scene: oldData.scenario || '一般',
    }

    console.log('已轉換舊格式數據')
    return newFormat
  }

  return oldData
}
```

---

## 🧠 邏輯與狀態問題

### 問題 6：車輛狀態異常

**症狀**：

- 車輛卡在某個狀態
- 狀態轉換邏輯錯誤
- 車輛無法正常移除

**除錯方法**：

```javascript
// 1. 車輛狀態追蹤器
class VehicleStateTracker {
  constructor() {
    this.stateHistory = new Map()
  }

  trackVehicle(vehicle) {
    if (!this.stateHistory.has(vehicle.id)) {
      this.stateHistory.set(vehicle.id, [])
    }

    const history = this.stateHistory.get(vehicle.id)
    history.push({
      state: vehicle.currentState,
      timestamp: Date.now(),
      position: { ...vehicle.position },
    })

    // 檢查是否卡在某個狀態過久
    this.checkStuckState(vehicle.id, history)
  }

  checkStuckState(vehicleId, history) {
    if (history.length < 10) return

    const recent = history.slice(-10)
    const sameState = recent.every((h) => h.state === recent[0].state)
    const timeDiff = recent[recent.length - 1].timestamp - recent[0].timestamp

    if (sameState && timeDiff > 30000) {
      // 30秒
      console.warn(`車輛 ${vehicleId} 可能卡在狀態 ${recent[0].state}`)
      this.debugVehicleState(vehicleId)
    }
  }

  debugVehicleState(vehicleId) {
    const vehicle = this.findVehicleById(vehicleId)
    if (vehicle) {
      console.log('車輛狀態診斷:', {
        id: vehicle.id,
        state: vehicle.currentState,
        position: vehicle.position,
        canProceed: vehicle.canProceed(window.trafficController.getCurrentLightStates()),
        hasElement: !!vehicle.element,
        hasTimeline: !!vehicle.timeline,
      })
    }
  }
}

// 2. 狀態修復工具
const fixVehicleState = (vehicleId) => {
  const vehicle = window.trafficController.vehicles.find((v) => v.id === vehicleId)
  if (!vehicle) {
    console.error('找不到車輛:', vehicleId)
    return
  }

  // 強制重置狀態
  if (vehicle.timeline) {
    vehicle.timeline.kill()
  }

  vehicle.currentState = 'waiting'
  vehicle.move()

  console.log('已重置車輛狀態:', vehicleId)
}
```

### 問題 7：交通燈同步問題

**症狀**：

- 多個方向同時顯示綠燈
- 燈號切換不協調
- 相位邏輯錯誤

**解決方案**：

```javascript
// 1. 燈號同步檢查器
const validateTrafficLightSync = () => {
  const controller = window.trafficController
  const states = controller.getCurrentLightStates()

  const issues = []

  // 檢查是否有多個方向同時綠燈
  const greenDirections = Object.keys(states).filter((dir) => states[dir] === 'green')
  if (greenDirections.length > 2) {
    issues.push('多個方向同時綠燈')
  }

  // 檢查對向燈號是否一致
  if (states.north !== states.south) {
    issues.push('南北向燈號不一致')
  }
  if (states.east !== states.west) {
    issues.push('東西向燈號不一致')
  }

  if (issues.length > 0) {
    console.error('燈號同步問題:', issues)
    return false
  }

  console.log('✓ 燈號同步正常')
  return true
}

// 2. 強制燈號同步
const forceLightSync = () => {
  const controller = window.trafficController

  // 重置到安全狀態（全紅燈）
  const safeState = {
    north: 'red',
    south: 'red',
    east: 'red',
    west: 'red',
  }

  controller.updateTrafficLights(safeState)

  // 3秒後恢復正常相位
  setTimeout(() => {
    controller.switchLights()
  }, 3000)

  console.log('已強制同步燈號')
}
```

---

## ⚡ 效能問題

### 問題 8：記憶體洩漏

**症狀**：

- 記憶體使用量持續增加
- 頁面變慢或當機
- 大量 DOM 元素未清理

**檢測與修復**：

```javascript
// 1. 記憶體洩漏檢測器
class MemoryLeakDetector {
  constructor() {
    this.initialMemory = this.getMemoryUsage()
    this.samples = []
    this.interval = null
  }

  startMonitoring(intervalMs = 10000) {
    this.interval = setInterval(() => {
      this.takeSample()
    }, intervalMs)
  }

  takeSample() {
    const current = this.getMemoryUsage()
    this.samples.push({
      timestamp: Date.now(),
      memory: current,
    })

    // 保持最近 20 個樣本
    if (this.samples.length > 20) {
      this.samples.shift()
    }

    this.analyzeMemoryTrend()
  }

  analyzeMemoryTrend() {
    if (this.samples.length < 5) return

    const recent = this.samples.slice(-5)
    const increasing = recent.every((sample, index) => {
      if (index === 0) return true
      return sample.memory > recent[index - 1].memory
    })

    if (increasing) {
      const growth = recent[recent.length - 1].memory - recent[0].memory
      if (growth > 10) {
        // 10MB 增長
        console.warn('偵測到可能的記憶體洩漏')
        this.reportLeakSources()
      }
    }
  }

  reportLeakSources() {
    console.log('記憶體洩漏分析:')
    console.log('車輛數量:', document.querySelectorAll('.vehicle').length)
    console.log('GSAP 動畫數量:', gsap.getTweensOf('*').length)
    console.log('事件監聽器數量:', this.countEventListeners())
  }

  getMemoryUsage() {
    return performance.memory ? Math.round(performance.memory.usedJSHeapSize / 1048576) : 0
  }
}

// 2. 記憶體清理工具
const performMemoryCleanup = () => {
  // 清理已移除的車輛 DOM 元素
  const vehicleElements = document.querySelectorAll('.vehicle')
  vehicleElements.forEach((element) => {
    if (!element.offsetParent) {
      element.remove()
    }
  })

  // 清理無效的 GSAP 動畫
  gsap.getTweensOf('*').forEach((tween) => {
    if (!tween.target || !document.contains(tween.target)) {
      tween.kill()
    }
  })

  // 觸發垃圾回收（僅在開發環境）
  if (window.gc && typeof window.gc === 'function') {
    window.gc()
  }

  console.log('記憶體清理完成')
}
```

### 問題 9：FPS 下降

**症狀**：

- 動畫不流暢
- 頁面回應遲緩
- CPU 使用率過高

**優化策略**：

```javascript
// 1. FPS 監控器
class FPSMonitor {
  constructor() {
    this.fps = 0
    this.frameCount = 0
    this.lastTime = performance.now()
    this.startMonitoring()
  }

  startMonitoring() {
    const updateFPS = (currentTime) => {
      this.frameCount++

      if (currentTime - this.lastTime >= 1000) {
        this.fps = this.frameCount
        this.frameCount = 0
        this.lastTime = currentTime

        this.checkPerformance()
      }

      requestAnimationFrame(updateFPS)
    }

    requestAnimationFrame(updateFPS)
  }

  checkPerformance() {
    if (this.fps < 30) {
      console.warn(`FPS 過低: ${this.fps}`)
      this.suggestOptimizations()
    }
  }

  suggestOptimizations() {
    const vehicleCount = document.querySelectorAll('.vehicle').length
    const animationCount = gsap.getTweensOf('*').length

    console.log('效能優化建議:')
    if (vehicleCount > 50) {
      console.log('- 車輛數量過多，考慮限制同時存在的車輛數')
    }
    if (animationCount > 100) {
      console.log('- 動畫數量過多，考慮使用動畫池管理')
    }
  }
}

// 2. 動畫優化器
class AnimationOptimizer {
  constructor() {
    this.maxConcurrentAnimations = 30
    this.animationQueue = []
    this.activeAnimations = new Set()
  }

  addAnimation(animationFn) {
    if (this.activeAnimations.size < this.maxConcurrentAnimations) {
      this.executeAnimation(animationFn)
    } else {
      this.animationQueue.push(animationFn)
    }
  }

  executeAnimation(animationFn) {
    const animation = animationFn()
    this.activeAnimations.add(animation)

    animation.eventCallback('onComplete', () => {
      this.activeAnimations.delete(animation)
      this.processQueue()
    })
  }

  processQueue() {
    if (this.animationQueue.length > 0 && this.activeAnimations.size < this.maxConcurrentAnimations) {
      const nextAnimation = this.animationQueue.shift()
      this.executeAnimation(nextAnimation)
    }
  }
}
```

---

## 🔧 配置與環境問題

### 問題 10：開發環境配置錯誤

**常見問題與解決方案**：

```bash
# 1. 依賴安裝問題
npm cache clean --force
rm -rf node_modules package-lock.json
npm install

# 2. 端口衝突
# 修改 quasar.config.js
devServer: {
  port: 9001, // 改用其他端口
  open: true
}

# 3. 環境變數問題
# 檢查 .env 文件是否存在
cat .env.development

# 4. 建置問題
npm run clean
npm run build
```

### 問題 11：瀏覽器相容性

**檢查清單**：

```javascript
// 1. 瀏覽器功能檢測
const checkBrowserSupport = () => {
  const features = {
    webGL: !!window.WebGLRenderingContext,
    requestAnimationFrame: !!window.requestAnimationFrame,
    classList: !!document.documentElement.classList,
    addEventListener: !!window.addEventListener,
    JSON: !!window.JSON,
    performance: !!window.performance,
  }

  const unsupported = Object.keys(features).filter((key) => !features[key])

  if (unsupported.length > 0) {
    console.error('瀏覽器不支援以下功能:', unsupported)
    alert('您的瀏覽器版本過舊，請升級到最新版本以獲得最佳體驗')
  } else {
    console.log('✓ 瀏覽器支援檢查通過')
  }

  return unsupported.length === 0
}

// 2. 降級處理
const enableFallbackMode = () => {
  console.log('啟用降級模式')

  // 禁用複雜動畫
  window.DISABLE_ANIMATIONS = true

  // 減少車輛數量
  window.MAX_VEHICLES = 10

  // 簡化視覺效果
  document.body.classList.add('low-performance-mode')
}
```

## 📋 除錯工具箱

### 全域除錯工具

```javascript
// 添加到瀏覽器控制台的全域工具
window.debugTools = {
  // 取得交通控制器
  getController: () => window.trafficController,

  // 列出所有車輛
  listVehicles: () => window.trafficController?.vehicles || [],

  // 強制移除所有車輛
  clearAllVehicles: () => {
    const controller = window.trafficController
    if (controller) {
      controller.vehicles.forEach((v) => v.remove?.())
      controller.vehicles = []
    }
  },

  // 重置系統
  resetSystem: () => {
    window.location.reload()
  },

  // 效能統計
  getPerformanceStats: () => ({
    vehicles: document.querySelectorAll('.vehicle').length,
    animations: gsap.getTweensOf('*').length,
    memory: performance.memory ? Math.round(performance.memory.usedJSHeapSize / 1048576) + 'MB' : 'N/A',
  }),

  // 模擬 API 錯誤
  simulateAPIError: () => {
    window.FORCE_API_ERROR = true
    console.log('API 錯誤模擬已啟用')
  },
}

console.log('除錯工具已載入，使用 debugTools 物件存取')
```

這個問題排除指南提供了系統可能遇到的主要問題及其解決方案，幫助開發者快速診斷和修復問題，確保系統穩定運行。
