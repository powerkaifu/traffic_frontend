# 擴展指南

## 🎯 擴展原則

在現有系統基礎上進行功能擴展時，應遵循以下原則：

1. **開放封閉原則**：對擴展開放，對修改封閉
2. **最小影響原則**：新功能不應影響現有功能
3. **向後相容性**：保持既有 API 的相容性
4. **模組化設計**：新功能應以模組形式添加

## 🚗 新增車輛類型

### 1. 擴展車輛配置

**步驟一：更新車輛配置**

```javascript
// src/classes/Vehicle.js - 在 VehicleConfig 中添加新類型
class VehicleConfig {
  static configs = {
    // 現有配置...

    // 新增車輛類型
    emergency: {
      // 緊急車輛
      width: 35,
      height: 80,
      speed: 150, // 較快速度
      priority: 1, // 最高優先級
      image: 'emergency_vehicle.png',
      color: '#FF0000',
    },

    bicycle: {
      // 自行車
      width: 15,
      height: 30,
      speed: 40, // 較慢速度
      priority: 3, // 較低優先級
      image: 'bicycle.png',
      color: '#00FF00',
    },

    bus: {
      // 公車
      width: 40,
      height: 100,
      speed: 60,
      priority: 2,
      image: 'bus.png',
      color: '#FFFF00',
      capacity: 50, // 載客量
    },
  }
}
```

**步驟二：更新工廠方法**

```javascript
// 擴展創建邏輯以支援新類型
static createVehicle(type, direction, behavior, currentLights) {
    const supportedTypes = ['small', 'motor', 'large', 'emergency', 'bicycle', 'bus'];

    if (!supportedTypes.includes(type)) {
        throw new Error(`不支援的車輛類型: ${type}`);
    }

    const config = VehicleConfig.getConfig(type, direction);
    const vehicle = new Vehicle(config, behavior, currentLights);

    // 為特殊車輛類型添加特殊處理
    switch (type) {
        case 'emergency':
            vehicle.setupEmergencyBehavior();
            break;
        case 'bicycle':
            vehicle.setupBicycleBehavior();
            break;
        case 'bus':
            vehicle.setupBusBehavior();
            break;
    }

    return vehicle;
}
```

**步驟三：添加特殊行為**

```javascript
// 緊急車輛特殊行為
setupEmergencyBehavior() {
    this.isEmergency = true;
    this.canIgnoreTrafficLights = true;

    // 緊急車輛音效
    this.playEmergencySound();

    // 閃爍燈光效果
    this.enableFlashingLights();
}

// 自行車特殊行為
setupBicycleBehavior() {
    this.usesBikeLane = true;
    this.hasReducedAcceleration = true;

    // 自行車專用路徑
    this.setupBikePathNavigation();
}

// 公車特殊行為
setupBusBehavior() {
    this.hasStops = true;
    this.passengers = 0;
    this.maxCapacity = this.config.capacity;

    // 公車站停靠邏輯
    this.setupBusStopBehavior();
}
```

### 2. 更新視覺資源

**添加新的圖片資源**

```
public/images/car/
├── emergency_down.png
├── emergency_left.png
├── emergency_right.png
├── emergency_top.png
├── bicycle_down.png
├── bicycle_left.png
├── bicycle_right.png
├── bicycle_top.png
├── bus_down.png
├── bus_left.png
├── bus_right.png
└── bus_top.png
```

## 🚦 新增燈號類型

### 1. 擴展燈號狀態

```javascript
// src/classes/TrafficLight.js - 添加新的燈號狀態
class TrafficLight {
  constructor(direction, container) {
    // 擴展狀態列表
    this.validStates = [
      'red',
      'yellow',
      'green',
      'flashing_red', // 閃爍紅燈
      'flashing_yellow', // 閃爍黃燈
      'arrow_left', // 左轉箭頭
      'arrow_right', // 右轉箭頭
      'pedestrian', // 行人專用
      'maintenance', // 維護模式
    ]

    // 其他初始化...
  }

  // 新增狀態轉換規則
  canTransitionTo(newState) {
    const currentState = this.currentState

    // 基本轉換規則
    const basicTransitions = {
      red: ['green', 'flashing_red', 'maintenance'],
      green: ['yellow', 'arrow_left', 'arrow_right'],
      yellow: ['red'],
      flashing_red: ['red', 'green'],
      flashing_yellow: ['yellow', 'red'],
      arrow_left: ['yellow', 'red'],
      arrow_right: ['yellow', 'red'],
      pedestrian: ['red', 'flashing_red'],
      maintenance: ['red'],
    }

    return basicTransitions[currentState]?.includes(newState) || false
  }
}
```

### 2. 新增視覺效果

```javascript
// 擴展視覺更新邏輯
updateVisualState() {
    const element = this.element;

    // 清除所有狀態類別
    element.className = `traffic-light ${this.direction}`;

    switch (this.currentState) {
        case 'flashing_red':
            element.classList.add('red', 'flashing');
            this.startFlashingAnimation('red');
            break;

        case 'flashing_yellow':
            element.classList.add('yellow', 'flashing');
            this.startFlashingAnimation('yellow');
            break;

        case 'arrow_left':
            element.classList.add('green', 'arrow-left');
            this.showArrow('left');
            break;

        case 'arrow_right':
            element.classList.add('green', 'arrow-right');
            this.showArrow('right');
            break;

        case 'pedestrian':
            element.classList.add('pedestrian');
            this.showPedestrianSignal();
            break;

        case 'maintenance':
            element.classList.add('maintenance');
            this.showMaintenanceIndicator();
            break;

        default:
            element.classList.add(this.currentState);
    }
}

// 閃爍動畫
startFlashingAnimation(color) {
    this.flashInterval = setInterval(() => {
        this.element.classList.toggle(`${color}-bright`);
    }, 500);
}

// 箭頭指示
showArrow(direction) {
    const arrow = document.createElement('div');
    arrow.className = `arrow arrow-${direction}`;
    this.element.appendChild(arrow);
}
```

## 🛣️ 新增道路類型

### 1. 道路配置系統

```javascript
// src/classes/RoadSystem.js - 新建道路系統
class RoadSystem {
  constructor() {
    this.roads = new Map()
    this.intersections = new Map()
    this.lanes = new Map()
  }

  addRoad(id, config) {
    const road = new Road(id, config)
    this.roads.set(id, road)
    return road
  }

  addIntersection(id, roads) {
    const intersection = new Intersection(id, roads)
    this.intersections.set(id, intersection)
    return intersection
  }
}

class Road {
  constructor(id, config) {
    this.id = id
    this.type = config.type // 'highway', 'street', 'bikeLane'
    this.lanes = config.lanes // 車道數量
    this.speedLimit = config.speedLimit
    this.direction = config.direction // 'bidirectional', 'oneway'
    this.specialFeatures = config.features || []
  }

  // 道路特殊功能
  hasFeature(feature) {
    return this.specialFeatures.includes(feature)
  }

  // 獲取允許的車輛類型
  getAllowedVehicleTypes() {
    switch (this.type) {
      case 'highway':
        return ['small', 'large', 'bus'] // 不允許機車和自行車
      case 'bikeLane':
        return ['bicycle'] // 只允許自行車
      case 'street':
      default:
        return ['small', 'motor', 'large', 'bus', 'bicycle']
    }
  }
}
```

### 2. 路徑規劃系統

```javascript
// src/classes/PathPlanning.js - 路徑規劃
class PathPlanner {
  constructor(roadSystem) {
    this.roadSystem = roadSystem
    this.pathCache = new Map()
  }

  findPath(start, end, vehicleType) {
    const cacheKey = `${start}-${end}-${vehicleType}`

    if (this.pathCache.has(cacheKey)) {
      return this.pathCache.get(cacheKey)
    }

    const path = this.calculatePath(start, end, vehicleType)
    this.pathCache.set(cacheKey, path)

    return path
  }

  calculatePath(start, end, vehicleType) {
    // 使用 A* 算法計算最佳路徑
    const openSet = [start]
    const closedSet = new Set()
    const gScore = new Map()
    const fScore = new Map()
    const cameFrom = new Map()

    gScore.set(start, 0)
    fScore.set(start, this.heuristic(start, end))

    while (openSet.length > 0) {
      const current = this.getLowestFScore(openSet, fScore)

      if (current === end) {
        return this.reconstructPath(cameFrom, current)
      }

      openSet.splice(openSet.indexOf(current), 1)
      closedSet.add(current)

      const neighbors = this.getNeighbors(current, vehicleType)

      for (const neighbor of neighbors) {
        if (closedSet.has(neighbor)) continue

        const tentativeGScore = gScore.get(current) + this.getDistance(current, neighbor)

        if (!openSet.includes(neighbor)) {
          openSet.push(neighbor)
        } else if (tentativeGScore >= gScore.get(neighbor)) {
          continue
        }

        cameFrom.set(neighbor, current)
        gScore.set(neighbor, tentativeGScore)
        fScore.set(neighbor, gScore.get(neighbor) + this.heuristic(neighbor, end))
      }
    }

    return null // 無法找到路徑
  }
}
```

## 🤖 新增 AI 演算法

### 1. 演算法介面標準化

```javascript
// src/classes/AI/AIAlgorithmInterface.js
class AIAlgorithmInterface {
  constructor(name) {
    this.name = name
    this.version = '1.0.0'
    this.capabilities = []
  }

  // 必須實現的方法
  async analyzeTrafficData(data) {
    throw new Error('analyzeTrafficData 方法必須被實現')
  }

  async generateRecommendation(analysis) {
    throw new Error('generateRecommendation 方法必須被實現')
  }

  // 可選實現的方法
  async learn(trainingData) {
    // 預設實現：不進行學習
    return { success: true, message: '此演算法不支援學習功能' }
  }

  async validate(recommendation) {
    // 預設實現：基本驗證
    return this.basicValidation(recommendation)
  }
}
```

### 2. 具體演算法實現

```javascript
// src/classes/AI/QLearningAlgorithm.js
class QLearningAlgorithm extends AIAlgorithmInterface {
  constructor() {
    super('Q-Learning')
    this.qTable = new Map()
    this.learningRate = 0.1
    this.discountFactor = 0.9
    this.explorationRate = 0.1
    this.capabilities = ['learning', 'optimization', 'prediction']
  }

  async analyzeTrafficData(data) {
    const state = this.encodeState(data)
    const possibleActions = this.getPossibleActions(state)

    return {
      currentState: state,
      possibleActions,
      stateValue: this.getStateValue(state),
      analysis: this.analyzeTrafficPatterns(data),
    }
  }

  async generateRecommendation(analysis) {
    const bestAction = this.selectAction(analysis.currentState)

    return {
      action: bestAction,
      confidence: this.getActionConfidence(analysis.currentState, bestAction),
      expectedReward: this.getExpectedReward(analysis.currentState, bestAction),
      reasoning: this.explainAction(bestAction),
    }
  }

  async learn(trainingData) {
    for (const episode of trainingData) {
      await this.processEpisode(episode)
    }

    return {
      success: true,
      episodesProcessed: trainingData.length,
      qTableSize: this.qTable.size,
    }
  }
}

// src/classes/AI/GeneticAlgorithm.js
class GeneticAlgorithm extends AIAlgorithmInterface {
  constructor() {
    super('Genetic Algorithm')
    this.populationSize = 100
    this.mutationRate = 0.01
    this.crossoverRate = 0.8
    this.generations = 0
    this.capabilities = ['optimization', 'evolution']
  }

  async analyzeTrafficData(data) {
    const population = this.generateInitialPopulation(data)
    const fitness = this.evaluatePopulation(population, data)

    return {
      population,
      fitness,
      bestIndividual: this.getBestIndividual(population, fitness),
      diversity: this.calculateDiversity(population),
    }
  }

  async generateRecommendation(analysis) {
    const optimizedSolution = await this.evolve(analysis)

    return {
      solution: optimizedSolution,
      fitness: this.evaluateFitness(optimizedSolution),
      generation: this.generations,
      reasoning: '基於遺傳算法演化出的最佳解',
    }
  }
}
```

### 3. 演算法管理器

```javascript
// src/classes/AI/AlgorithmManager.js
class AlgorithmManager {
  constructor() {
    this.algorithms = new Map()
    this.currentAlgorithm = null
    this.performanceMetrics = new Map()
  }

  registerAlgorithm(algorithm) {
    if (!(algorithm instanceof AIAlgorithmInterface)) {
      throw new Error('演算法必須繼承自 AIAlgorithmInterface')
    }

    this.algorithms.set(algorithm.name, algorithm)
    this.performanceMetrics.set(algorithm.name, {
      totalCalls: 0,
      totalTime: 0,
      successRate: 0,
      averageAccuracy: 0,
    })
  }

  async switchAlgorithm(algorithmName) {
    if (!this.algorithms.has(algorithmName)) {
      throw new Error(`演算法 ${algorithmName} 未註冊`)
    }

    this.currentAlgorithm = this.algorithms.get(algorithmName)
    console.log(`切換到演算法: ${algorithmName}`)
  }

  async processTrafficData(data) {
    if (!this.currentAlgorithm) {
      throw new Error('未選擇演算法')
    }

    const startTime = performance.now()

    try {
      const analysis = await this.currentAlgorithm.analyzeTrafficData(data)
      const recommendation = await this.currentAlgorithm.generateRecommendation(analysis)

      const endTime = performance.now()
      this.updateMetrics(this.currentAlgorithm.name, endTime - startTime, true)

      return recommendation
    } catch (error) {
      const endTime = performance.now()
      this.updateMetrics(this.currentAlgorithm.name, endTime - startTime, false)
      throw error
    }
  }
}
```

## 📊 新增數據分析功能

### 1. 數據收集器擴展

```javascript
// src/classes/Analytics/DataCollector.js
class AdvancedDataCollector {
  constructor() {
    this.collectors = new Map()
    this.storage = new DataStorage()
    this.processors = new Map()
  }

  addCollector(name, collector) {
    this.collectors.set(name, collector)
  }

  addProcessor(name, processor) {
    this.processors.set(name, processor)
  }

  async collectAllData() {
    const results = {}

    for (const [name, collector] of this.collectors) {
      try {
        results[name] = await collector.collect()
      } catch (error) {
        console.error(`數據收集器 ${name} 發生錯誤:`, error)
        results[name] = null
      }
    }

    return results
  }

  async processData(rawData) {
    const processedData = {}

    for (const [name, processor] of this.processors) {
      if (rawData[name]) {
        processedData[name] = await processor.process(rawData[name])
      }
    }

    return processedData
  }
}

// 特定的數據收集器
class VehicleFlowCollector {
  async collect() {
    return {
      timestamp: Date.now(),
      flows: this.calculateFlows(),
      density: this.calculateDensity(),
      speed: this.calculateAverageSpeed(),
    }
  }
}

class EnvironmentCollector {
  async collect() {
    return {
      timestamp: Date.now(),
      weather: await this.getWeatherData(),
      timeOfDay: this.getTimeOfDay(),
      specialEvents: this.getSpecialEvents(),
    }
  }
}
```

### 2. 報表生成系統

```javascript
// src/classes/Analytics/ReportGenerator.js
class ReportGenerator {
  constructor() {
    this.templates = new Map()
    this.exporters = new Map()
  }

  addTemplate(name, template) {
    this.templates.set(name, template)
  }

  addExporter(format, exporter) {
    this.exporters.set(format, exporter)
  }

  async generateReport(templateName, data, options = {}) {
    const template = this.templates.get(templateName)
    if (!template) {
      throw new Error(`報表模板 ${templateName} 不存在`)
    }

    const report = await template.generate(data, options)
    return report
  }

  async exportReport(report, format) {
    const exporter = this.exporters.get(format)
    if (!exporter) {
      throw new Error(`不支援的匯出格式: ${format}`)
    }

    return await exporter.export(report)
  }
}

// 報表模板範例
class TrafficSummaryTemplate {
  async generate(data, options) {
    return {
      title: '交通狀況摘要報告',
      period: options.period,
      summary: {
        totalVehicles: data.totalVehicles,
        averageWaitTime: data.averageWaitTime,
        throughput: data.throughput,
        efficiency: this.calculateEfficiency(data),
      },
      charts: this.generateCharts(data),
      recommendations: this.generateRecommendations(data),
    }
  }
}
```

這個擴展指南提供了系統各個層面的擴展方法，讓開發者能夠在不破壞現有架構的基礎上，靈活地添加新功能和特性。
