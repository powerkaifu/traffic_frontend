# 設計模式應用

## 🎯 設計模式選擇原則

本系統採用多種設計模式的組合，每個模式的選擇都基於特定的業務需求和技術考量：

1. **職責分離**：確保每個類別有明確的單一職責
2. **鬆散耦合**：降低組件間的依賴關係
3. **高內聚性**：相關功能集中管理
4. **可擴展性**：便於未來功能擴展和修改
5. **可維護性**：提升代碼的可讀性和維護性

## 🏗️ TrafficLightController 設計模式

### Observer Pattern（觀察者模式）

**應用原因**：

- 車輛需要即時感知燈號變化
- 系統狀態變化需要通知多個組件
- 實現鬆散耦合的事件通知機制

**實現方式**：

```javascript
// 車輛註冊為觀察者
registerVehicle(vehicle) {
    this.vehicles.push(vehicle);
}

// 燈號變化通知所有車輛
updateTrafficLights(lightStates) {
    this.vehicles.forEach(vehicle => {
        vehicle.onTrafficLightChange(lightStates);
    });
}
```

**優點**：

- 支援一對多的依賴關係
- 動態增減觀察者
- 降低主體和觀察者間的耦合

### Singleton Pattern（單例模式）

**應用原因**：

- 確保整個系統只有一個交通控制中心
- 避免多個控制器衝突
- 提供全域存取點

**實現方式**：

```javascript
class TrafficLightController {
  constructor() {
    if (TrafficLightController.instance) {
      return TrafficLightController.instance
    }
    // 初始化邏輯
    TrafficLightController.instance = this
  }
}
```

**優點**：

- 確保實例唯一性
- 提供全域存取點
- 延遲初始化節約資源

### State Pattern（狀態模式）

**應用原因**：

- 燈號控制有明確的狀態轉換
- 不同狀態下的行為差異很大
- 需要支援複雜的狀態轉換邏輯

**實現方式**：

```javascript
// 狀態轉換邏輯
switchLights() {
    const currentPhase = this.getCurrentPhase();
    const nextPhase = this.getNextPhase(currentPhase);
    this.transitionToPhase(nextPhase);
}
```

**優點**：

- 狀態轉換邏輯清晰
- 易於擴展新狀態
- 避免大量條件判斷

## 🚗 Vehicle 設計模式

### Factory Pattern（工廠模式）

**應用原因**：

- 需要根據不同參數創建不同類型車輛
- 車輛創建邏輯複雜，需要統一管理
- 支援動態車輛類型擴展

**實現方式**：

```javascript
static createVehicle(type, direction, behavior, currentLights) {
    const config = VehicleConfig.getConfig(type, direction);
    return new Vehicle(config, behavior, currentLights);
}
```

**優點**：

- 創建邏輯集中管理
- 易於擴展新車型
- 隱藏複雜的創建過程

### Strategy Pattern（策略模式）

**應用原因**：

- 車輛有不同的行為策略（直行、轉彎）
- 運行時需要動態切換行為
- 支援新行為策略的擴展

**實現方式**：

```javascript
// 不同的行為策略
const strategies = {
  straight: this.executeStraightBehavior,
  left: this.executeLeftTurnBehavior,
  right: this.executeRightTurnBehavior,
  'u-turn': this.executeUTurnBehavior,
}
```

**優點**：

- 算法可以自由切換
- 避免複雜的條件語句
- 支援開放封閉原則

### State Pattern（狀態模式）

**應用原因**：

- 車輛在模擬中有不同狀態（等待、移動、轉彎）
- 狀態轉換有明確的規則
- 不同狀態下的行為完全不同

**實現方式**：

```javascript
// 狀態管理
setState(newState) {
    this.currentState = newState;
    this.stateHandlers[newState]?.call(this);
}
```

**優點**：

- 狀態轉換邏輯清晰
- 易於增加新狀態
- 提升代碼可讀性

### Command Pattern（命令模式）

**應用原因**：

- 動畫執行需要封裝為命令
- 支援動畫的暫停、恢復、取消
- 實現複雜動畫序列的組合

**實現方式**：

```javascript
// 動畫命令封裝
executeAnimation(animationCommand) {
    this.currentAnimation = animationCommand;
    animationCommand.execute();
}
```

**優點**：

- 動畫控制更靈活
- 支援動畫的撤銷和重做
- 易於實現複雜動畫序列

## 🚦 TrafficLight 設計模式

### State Pattern（狀態模式）

**應用原因**：

- 交通燈有明確的狀態（紅、黃、綠）
- 狀態切換有安全規則
- 不同狀態的視覺表現不同

**實現方式**：

```javascript
// 狀態切換
setState(newState) {
    if (this.canTransitionTo(newState)) {
        this.currentState = newState;
        this.updateVisualState();
    }
}
```

**優點**：

- 確保安全的狀態轉換
- 狀態邏輯集中管理
- 易於擴展新狀態

### Strategy Pattern（策略模式）

**應用原因**：

- 不同燈號的顯示策略不同
- 支援不同的視覺效果主題
- 運行時動態切換顯示策略

**實現方式**：

```javascript
// 顯示策略
const displayStrategies = {
  normal: this.normalDisplay,
  highlight: this.highlightDisplay,
  minimal: this.minimalDisplay,
}
```

**優點**：

- 顯示邏輯可替換
- 支援主題切換
- 易於添加新的顯示效果

## 🔄 模式協作

### 模式間的協調

1. **Observer + Factory**：工廠創建的車輛自動註冊為觀察者
2. **State + Strategy**：在不同狀態下採用不同策略
3. **Command + State**：狀態轉換透過命令模式觸發
4. **Singleton + Observer**：單例控制器管理所有觀察者

### 系統整體協調

```javascript
// 模式協作示例
class SystemCoordinator {
  constructor() {
    this.controller = new TrafficLightController() // Singleton
    this.vehicleFactory = new VehicleFactory() // Factory
    this.setupObservers() // Observer
  }

  createVehicle(params) {
    const vehicle = this.vehicleFactory.create(params) // Factory
    this.controller.registerVehicle(vehicle) // Observer
    vehicle.setState('waiting') // State
    return vehicle
  }
}
```

## 🎯 設計模式帶來的好處

### 代碼品質提升

- **可讀性**：模式提供了標準的解決方案
- **可維護性**：職責分離使修改影響範圍最小
- **可測試性**：模組化設計便於單元測試
- **可重用性**：模式化的代碼易於重用

### 系統架構優勢

- **鬆散耦合**：組件間依賴關係最小
- **高內聚性**：相關功能集中在一起
- **可擴展性**：新功能可以無縫集成
- **可配置性**：透過策略模式支援配置驅動

### 團隊開發效益

- **共同語言**：設計模式提供了團隊溝通的共同語言
- **最佳實踐**：遵循業界認可的最佳實踐
- **知識傳承**：標準化的設計便於知識傳承
- **減少錯誤**：成熟的模式減少設計錯誤

這些設計模式的合理應用，使得系統具備了良好的架構基礎，為後續的功能擴展和維護提供了強有力的支撐。
